/* global window */
import React from 'react';
import PropTypes from 'prop-types';
import loadScript from 'load-script2';

const {
  useCallback,
  useEffect,
  useState,
  useRef,
} = React;

function noop() {}

/**
 * Load the YouTube Player SDk.
 *
 * @returns {null|YT}
 */
function useSdk() {
  const [sdk, setSdk] = useState(null);
  useEffect(() => {
    let unmounted = false;
    if (typeof window.YT === 'object' && typeof window.YT.ready === 'function') {
      window.YT.ready(() => {
        if (!unmounted) setSdk(window.YT);
      });
    } else {
      loadScript('https://www.youtube.com/iframe_api', (err) => {
        // TODO handle this
        if (err) throw err;
        window.YT.ready(() => {
          if (!unmounted) setSdk(window.YT);
        });
      });
    }
    return () => {
      unmounted = true;
    };
  }, []);
  return sdk;
}

/**
 * Apply an effect to a player instance.
 */
function usePlayerEffect(player, effect, deps) {
  useEffect(() => {
    if (player) {
      effect();
    }
  }, [player].concat(deps));
}

/**
 * Attach an event listener to a YouTube Player instance.
 */
function usePlayerEvent(player, name, listener) {
  const prevListener = useRef(null);
  usePlayerEffect(player, () => {
    if (prevListener.current) {
      player.removeEventListener(name, prevListener.current);
    }
    if (listener) {
      player.addEventListener(name, listener);
    }
    prevListener.current = listener;
  }, [listener]);
}

/**
 * Manage YouTube player state.
 *
 * @param {Element} container
 * @param {object} props
 */
function useYouTubePlayer(container, props) {
  const {
    video,
    // Options
    width,
    height,
    autoplay,
    showCaptions,
    controls,
    disableKeyboard,
    allowFullscreen,
    lang,
    annotations,
    startSeconds = 0,
    endSeconds,
    modestBranding,
    playsInline,
    showRelatedVideos,
    showInfo,
    // State
    muted,
    suggestedQuality,
    volume,
    paused,
  } = props;

  const [player, setPlayer] = useState(null);
  const sdk = useSdk();
  // Update setup options so up-to-date ones can be used when initialising the player.
  const initOptions = useRef({});
  if (!player) {
    Object.assign(initOptions.current, {
      videoId: video,
      width,
      height,
      playerVars: {
        autoplay,
        cc_load_policy: showCaptions ? 1 : 0,
        controls: controls ? 1 : 0,
        disablekb: disableKeyboard ? 1 : 0,
        fs: allowFullscreen ? 1 : 0,
        hl: lang,
        iv_load_policy: annotations ? 1 : 3,
        start: startSeconds,
        end: endSeconds,
        modestbranding: modestBranding ? 1 : 0,
        playsinline: playsInline ? 1 : 0,
        rel: showRelatedVideos ? 1 : 0,
        showinfo: showInfo ? 1 : 0,
      },
    });
  }

  useEffect(() => {
    // wait for a bit longer.
    if (!sdk) return () => {};

    const p = new sdk.Player(container, {
      ...initOptions.current,
      events: {
        onReady() {
          setPlayer(p);
        },
      },
    });

    return () => {
      setPlayer(null);
      p.destroy();
    };
  }, [container, sdk]);

  // Handle props changes.

  usePlayerEffect(player, () => {
    if (muted) {
      player.mute();
    } else {
      player.unMute();
    }
  }, [muted]);
  usePlayerEffect(player, () => {
    player.setPlaybackQuality(suggestedQuality);
  }, [suggestedQuality]);
  usePlayerEffect(player, () => {
    player.setVolume(volume * 100);
  }, [volume]);
  usePlayerEffect(player, () => {
    const state = player.getPlayerState();
    if (paused && state !== 2) {
      player.pauseVideo();
    } else if (!paused && state === 2) {
      player.playVideo();
    }
  }, [volume]);
  usePlayerEffect(player, () => {
    player.getIframe().width = width;
    player.getIframe().height = height;
  }, [width, height]);
  usePlayerEffect(player, () => {
    if (!video) {
      player.stopVideo();
    } else {
      const opts = {
        videoId: video,
        startSeconds,
        endSeconds,
      };
      if (autoplay) {
        player.loadVideoById(opts);
      } else {
        player.cueVideoById(opts);
      }
    }
  }, [video]);

  return player;
}

function YouTube({
  video,
  id,
  className,
  style,
  width,
  height,
  paused,
  autoplay = false,
  showCaptions = false,
  controls = true,
  disableKeyboard = false,
  allowFullscreen = true,
  lang,
  annotations = true,
  startSeconds,
  endSeconds,
  modestBranding = false,
  playsInline = false,
  showRelatedVideos = true,
  showInfo = true,
  volume,
  muted,
  suggestedQuality,
  playbackRate,
  onReady,
  onError,
  onCued = noop,
  onBuffering = noop,
  onPlaying = noop,
  onPause = noop,
  onEnd = noop,
  onStateChange,
  onPlaybackRateChange,
  onPlaybackQualityChange,
}) {
  const container = useRef(null);
  const player = useYouTubePlayer(container.current, {
    video,
    width,
    height,
    paused,
    autoplay,
    showCaptions,
    controls,
    disableKeyboard,
    allowFullscreen,
    lang,
    annotations,
    startSeconds,
    endSeconds,
    modestBranding,
    playsInline,
    showRelatedVideos,
    showInfo,
    volume,
    muted,
    suggestedQuality,
    playbackRate,
  });

  const triageStateChange = useCallback((event) => {
    const State = window.YT.PlayerState;
    switch (event.data) {
      case State.CUED:
        onCued(event);
        break;
      case State.BUFFERING:
        onBuffering(event);
        break;
      case State.PAUSED:
        onPause(event);
        break;
      case State.PLAYING:
        onPlaying(event);
        break;
      case State.ENDED:
        onEnd(event);
        break;
      default:
        // Nothing
    }
  }, [onCued, onBuffering, onPause, onPlaying, onEnd]);

  usePlayerEvent(player, 'onReady', onReady);
  usePlayerEvent(player, 'onStateChange', onStateChange);
  usePlayerEvent(player, 'onStateChange', triageStateChange);
  usePlayerEvent(player, 'onPlaybackQualityChange', onPlaybackQualityChange);
  usePlayerEvent(player, 'onPlaybackRateChange', onPlaybackRateChange);
  usePlayerEvent(player, 'onError', onError);

  return (
    <div
      id={id}
      className={className}
      style={style}
      ref={container}
    />
  );
}

if (process.env.NODE_ENV !== 'production') {
  YouTube.propTypes = {
    /**
     * An 11-character string representing a YouTube video ID..
     */
    video: PropTypes.string,
    /**
     * DOM ID for the player element.
     */
    id: PropTypes.string,
    /**
     * CSS className for the player element.
     */
    className: PropTypes.string,
    /**
     * Inline style for container element.
     */
    style: PropTypes.object, // eslint-disable-line react/forbid-prop-types
    /**
     * Width of the player element.
     */
    width: PropTypes.oneOfType([
      PropTypes.number,
      PropTypes.string,
    ]),
    /**
     * Height of the player element.
     */
    height: PropTypes.oneOfType([
      PropTypes.number,
      PropTypes.string,
    ]),
    /**
     * Pause the video.
     */
    paused: PropTypes.bool,
    /**
     * Whether the video should start playing automatically.
     *
     * https://developers.google.com/youtube/player_parameters#autoplay
     */
    autoplay: PropTypes.bool,
    /**
     * Whether to show captions below the video.
     *
     * https://developers.google.com/youtube/player_parameters#cc_load_policy
     */
    showCaptions: PropTypes.bool,
    /**
     * Whether to show video controls.
     *
     * https://developers.google.com/youtube/player_parameters#controls
     */
    controls: PropTypes.bool,
    /**
     * Ignore keyboard controls.
     *
     * https://developers.google.com/youtube/player_parameters#disablekb
     */
    disableKeyboard: PropTypes.bool,
    /**
     * Whether to display the fullscreen button.
     *
     * https://developers.google.com/youtube/player_parameters#fs
     */
    allowFullscreen: PropTypes.bool,
    /**
     * The player's interface language. The parameter value is an ISO 639-1
     * two-letter language code or a fully specified locale.
     *
     * https://developers.google.com/youtube/player_parameters#hl
     */
    lang: PropTypes.string,
    /**
     * Whether to show annotations on top of the video.
     *
     * https://developers.google.com/youtube/player_parameters#iv_load_policy
     */
    annotations: PropTypes.bool,
    /**
     * Time in seconds at which to start playing the video.
     *
     * https://developers.google.com/youtube/player_parameters#start
     */
    startSeconds: PropTypes.number,
    /**
     * Time in seconds at which to stop playing the video.
     *
     * https://developers.google.com/youtube/player_parameters#end
     */
    endSeconds: PropTypes.number,
    /**
     * Remove most YouTube logos from the player.
     *
     * https://developers.google.com/youtube/player_parameters#modestbranding
     */
    modestBranding: PropTypes.bool,
    /**
     * Whether to play the video inline on iOS, instead of fullscreen.
     *
     * https://developers.google.com/youtube/player_parameters#playsinline
     */
    playsInline: PropTypes.bool,
    /**
     * Whether to show related videos after the video is over.
     *
     * https://developers.google.com/youtube/player_parameters#rel
     */
    showRelatedVideos: PropTypes.bool,
    /**
     * Whether to show video information (uploader, title, etc) before the video
     * starts.
     *
     * **This parameter has been deprecated and has no effect.**
     *
     * https://developers.google.com/youtube/player_parameters#showinfo
     */
    showInfo: PropTypes.bool,
    /**
     * The playback volume, **as a number between 0 and 1**.
     */
    volume: PropTypes.number,
    /**
     * Whether the video's sound should be muted.
     */
    muted: PropTypes.bool,
    /**
     * The suggested playback quality.
     *
     * https://developers.google.com/youtube/iframe_api_reference#Playback_quality
     */
    suggestedQuality: PropTypes.string,
    /**
     * Playback speed.
     *
     * https://developers.google.com/youtube/iframe_api_reference#setPlaybackRate
     */
    playbackRate: PropTypes.number,
    /**
     * Sent when the YouTube player API has loaded.
     */
    onReady: PropTypes.func,
    /**
     * Sent when the player triggers an error.
     */
    onError: PropTypes.func,
    /**
     * Sent when the video is cued and ready to play.
     */
    onCued: PropTypes.func,
    /**
     * Sent when the video is buffering.
     */
    onBuffering: PropTypes.func,
    /**
     * Sent when playback has been started or resumed.
     */
    onPlaying: PropTypes.func,
    /**
     * Sent when playback has been paused.
     */
    onPause: PropTypes.func,
    /**
     * Sent when playback has stopped.
     */
    onEnd: PropTypes.func,
    onStateChange: PropTypes.func,
    onPlaybackRateChange: PropTypes.func,
    onPlaybackQualityChange: PropTypes.func,
  };
}

export default YouTube;
